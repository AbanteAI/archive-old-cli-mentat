{
    "title": "Add test for config.save",
    "description": "",
    "id": "2c7af07dbac84ceb84a7018ce3c97b05",
    "parent_id": "80eb7e6d9243490bb4f0b086cd8f7d4e",
    "repo": "https://github.com/AbanteAI/mentat",
    "merge_base": "6deda27",
    "diff_merge_base": "diff --git a/scripts/evaluate_samples.py b/scripts/evaluate_samples.py\nindex 6ecb35f..507cae5 100644\n--- a/scripts/evaluate_samples.py\n+++ b/scripts/evaluate_samples.py\n@@ -24,2 +24,7 @@ from mentat.session_context import SESSION_CONTEXT\n from mentat.utils import clone_repo, mentat_dir_path\n+from tests.benchmarks.benchmark_runner import (\n+    grade_diff_syntax,\n+    grade_model_response,\n+    compare_diffs,\n+)\n \n@@ -125,2 +130,3 @@ async def main():\n \n+    results = {}\n     for sample_file in sample_files:\n@@ -128,4 +134,13 @@ async def main():\n             sample = Sample.load(sample_file)\n-            results = await evaluate_sample(sample)\n-            print(f\"Results for {sample_file.stem}: {json.dumps(results, indent=4)}\")\n+            print(f\"Evaluating sample {sample.id[:8]}\")\n+            print(f\"  Prompt: {sample.message_prompt}\")\n+            diff_eval = await evaluate_sample(sample)\n+            message_eval = \"\"  # TODO: return from evaluate_sample\n+            \n+            diff_grade = await grade_diff_syntax(diff_eval)\n+            print(f\"  Diff Grade: {diff_grade}\")\n+            response_grade = await grade_model_response(message_eval + \"\\n\" + diff_eval)\n+            print(f\"  Response Grade: {response_grade}\")\n+            comparison_grade = await compare_diffs(sample.diff_edit, diff_eval)\n+            print(f\"  Comparison Grade: {comparison_grade}\")\n         else:\n",
    "diff_active": "diff --git a/mentat/config.py b/mentat/config.py\nindex b0cb490..52af01c 100644\n--- a/mentat/config.py\n+++ b/mentat/config.py\n@@ -85,3 +85,3 @@ class Config:\n         },\n-        converter=parser_map.get,  # pyright: ignore\n+        converter=lambda name: parser_map.get(name)(),  # pyright: ignore\n         validator=validators.instance_of(Parser),  # pyright: ignore\n@@ -247 +247,16 @@ class Config:\n         self._errors = []\n+\n+    def save(self, path: Path | None = None) -> None:\n+        config_dict = attr.asdict(\n+            self, filter=lambda a, value: a.name != \"parser\"\n+        )\n+        # Find the key in parser_map corresponding to the active parser instance\n+        parser_key = next(\n+            key for key, cls in parser_map.items() if isinstance(self.parser, cls)\n+        )\n+        config_dict[\"parser\"] = parser_key  # Add the parser key to the dictionary\n+\n+        # Use the provided path or default to user_config_path\n+        save_path = path if path is not None else user_config_path\n+        with open(save_path, \"w\") as config_file:\n+            json.dump(config_dict, config_file, indent=4)\ndiff --git a/mentat/parsers/parser_map.py b/mentat/parsers/parser_map.py\nindex 2ff0777..91e141c 100644\n--- a/mentat/parsers/parser_map.py\n+++ b/mentat/parsers/parser_map.py\n@@ -6,9 +6,9 @@ from mentat.parsers.unified_diff_parser import UnifiedDiffParser\n \n-parser_map: dict[str, Parser] = {\n-    \"block\": BlockParser(),\n-    \"replacement\": ReplacementParser(),\n-    \"unified-diff\": UnifiedDiffParser(),\n+parser_map: dict[str, type[Parser]] = {\n+    \"block\": BlockParser,\n+    \"replacement\": ReplacementParser,\n+    \"unified-diff\": UnifiedDiffParser,\n     # JsonParser is experimental and has no streaming or tests and seems worse than other formats\n     # Don't use it! But if you need to, make sure to set to a model that can use the JSON response_format\n-    \"json\": JsonParser(),\n+    \"json\": JsonParser,\n }\ndiff --git a/scripts/translate_transcript.py b/scripts/translate_transcript.py\nindex e56667a..e82d22c 100755\n--- a/scripts/translate_transcript.py\n+++ b/scripts/translate_transcript.py\n@@ -14,3 +14,3 @@ from mentat.utils import convert_string_to_asynciter\n \n-parser_map[\"git\"] = GitParser()\n+parser_map[\"git\"] = GitParser\n \n@@ -60,4 +60,4 @@ if __name__ == \"__main__\":\n \n-    starting_parser = parser_map[args.starting_format]\n-    ending_parser = parser_map[args.ending_format]\n+    starting_parser = parser_map[args.starting_format]()\n+    ending_parser = parser_map[args.ending_format]()\n     with open(args.transcript, \"r\") as f:\n",
    "message_history": [
        {
            "role": "assistant",
            "content": "I will add a new method called `save` to the `Config` class in `mentat/config.py`. This method will take an optional `path` argument. It will use `attr.asdict` to serialize the config object to a dictionary, except for the `parser` attribute, for which it will find the corresponding key in the `parser_map`. Then it will save the dictionary as JSON to the specified `path` or to the `user_config_path` if no path is provided.\n\nSteps:\n1. Add the `save` method to the `Config` class in `mentat/config.py`."
        },
        {
            "role": "user",
            "content": "Now add a new method to config called 'save' with an optional 'path' arg. It should save the config using attr.asdict, except for the parser; for that, we need to use the parser_map to determine the key corresponding to the active parser, and add that. Then save it as json to either the path or the user_config_path."
        },
        {
            "role": "assistant",
            "content": "I will update the `parser_map` in `mentat/parsers/parser_map.py` to return the class instead of an instance. Then, I will modify all the places where `parser_map` is called in `mentat/config.py` and `scripts/translate_transcript.py` to instantiate the class by adding `()` after the `parser_map` call.\n\nSteps:\n1. Update `parser_map` to return the class instead of an instance.\n2. Update `Config` class in `mentat/config.py` where `parser_map.get` is used as a converter.\n3. Update `translate_transcript.py` where `parser_map` is used to get the starting and ending parsers."
        },
        {
            "role": "user",
            "content": "Change parser_map so that it returns the class, not an instance of the class, and update all the places where it's called to add a '()' afterwards."
        }
    ],
    "message_prompt": "Add a test for the new config.save method.",
    "message_edit": "I will add a new test case for the `save` method in the `Config` class within the `tests/config_test.py` file. This test will verify that the `save` method correctly serializes the `Config` object to JSON, including the special handling for the `parser` attribute, and writes it to the specified path or to the default `user_config_path`.\n\nSteps:\n1. Add a new test case in `tests/config_test.py` for the `save` method.",
    "context": [
        "mentat/config.py",
        "tests/config_test.py"
    ],
    "diff_edit": "diff --git a/tests/config_test.py b/tests/config_test.py\nindex 54f702f..e94425d 100644\n--- a/tests/config_test.py\n+++ b/tests/config_test.py\n@@ -1 +1,2 @@\n+import json\n import argparse\n@@ -95 +96,18 @@ async def test_invalid_config(mock_config_errors):\n     assert config.model == \"test\"\n+    \n+\n+@pytest.mark.asyncio\n+async def test_config_save(tmp_path):\n+    config = Config()\n+    config.model = \"test-model\"\n+    config.temperature = 0.7\n+    config.parser = \"replacement\"\n+\n+    save_path = tmp_path / \"test_config.json\"\n+    config.save(save_path)\n+    config2 = Config()\n+    config2.load_file(save_path)\n+\n+    assert config2.model == config.model\n+    assert config2.temperature == config.temperature\n+    assert isinstance(config2.parser, ReplacementParser)\n",
    "test_command": "",
    "version": "0.1.0"
}